#!/usr/bin/env bash

main() {
    _get_commandline_opts $@
    _set_home_dirs
    _load_dcshell_lib
    _load_yaml_config
    init_sudo
    image_name_tagged="${IMAGENAME}${image_tag}"  # add tag from -t
    _remove_previous_image  # i.e. image:lastest or custom tag specified with -t
    _remove_all_buildnumber_tags # filters all tags with the Bn.m pattern
    _exec_build_command
    if [[ "$manifest" ]]; then
        if [[ "$MANIFEST_SCOPE" ]]; then
            _generate_manifest_and_image_build_number
            _tag_with_build_number
        else
            echo "MANIFEST_SCOPE not set - no build number generated."
        fi
    fi
    _push_image
}


_get_commandline_opts() {
    manifest='True'
    unset image_tag
    push_latest='True'
    f_index=0
    while getopts ":cD:hf:klmMprt:v" opt; do
      case $opt in
        c) CACHEOPT="--no-cache";;
        D) projdir=$OPTARG; projdir_opt="-D $OPTARG";;
        f) dc_config_list[$f_index]=$OPTARG;
           dc_config_opt="${dc_config_opt} -f ${OPTARG}";
           f_index=$((f_index+1));;
        k) keep_opt='True';;
        l) unset push_latest;;
        m) manifest='True';;
        M) unset manifest;;
        p) push='True';;
        r) remove_img='True';;
        t) image_tag=":${OPTARG}";;
        v) verbose='True';;
        :) echo "Option -$OPTARG requires an argument"; exit 1;;
        *) echo "usage from shell: $0 [-b] [-c] [-D path][-f file...] [-h] [-k] [-l] [-m] [-M] [-p] [-r] [-t tag] [cmd]
             -c  do not use cache (build --no-cache)
             -D  specify project directory (file parameters will be relative to this path)
             -f  compose file (later files update keys in former ones)
             -k  keep previous build tags (default: remove all 'B*' tags)
             -l  do not push image:latest (only :<buildno> or tag from -t)
             -m  generate manifest for build number generation (default)
             -M  do not generate manifest for build number generation
             -p  push after build (pushing :latest depends on -l)
             -r  remove existing image (all tags: docker rmi -f imageid)
             -t  add this custom tag to the build target name
             -v  verbose

           The -m and -t tagging require that there is not tag on the image element in the compose file.
           To explicitly specify a registry set DOCKER_REGISTRY_PREFIX, which must include a trailing slash.

           To generate build numbers MANIFEST_SCOPE must be set to 'local' or 'global'.
           All services defined in the compose file are build, but the manifest is generated only for the first one.

           "; exit 0;;
      esac
    done
    shift $((OPTIND-1))
    # post-process -f argument(s)
    if (( $f_index==0 )); then
         echo "at least one -f argument is required"; exit 1
    fi
    dc_opt_prefixed=''
    for f in ${dc_config_list[@]}; do
        [[ "$projdir" ]] && f="${projdir}/${f}"
        if [[ ! -f "$f" ]]; then
            echo -f $f must be a file; exit 1
        else
            dc_opt_prefixed="$dc_opt_prefixed -f ${f}"
        fi
    done
    dc_config_base=${dc_config_list[0]}
}

_set_home_dirs() {
    export DCSHELL_HOME=$(cd $(dirname $BASH_SOURCE[0]) && pwd)
    if [[ "$projdir" ]]; then
        export DC_PROJHOME=$projdir
    else
        export DC_PROJHOME=$(cd $(dirname $DCSHELL_HOME) && pwd)
    fi
}


_load_dcshell_lib() {
    source $DCSHELL_HOME/dcshell_lib.sh
}


_load_yaml_config() {
    check_python3
    # config.py will create 'export X=Y' statemend on stdout; source it by executing the subshell
    $($DCSHELL_HOME/config.py $projdir_opt -k container_name -k image -k build.dockerfile $dc_config_opt)
    if (( $? )); then
        echo "config.py failed"; exit 1
    fi
}


_remove_previous_image() {
    if [[ "$remove_img" ]]; then
        image_id=$(${sudo} docker images ls --filter "reference=${image_name_tagged}" -q)
        cmd="${sudo} docker rmi -f ${image_id}"
        [[ "$verbose" ]] && echo $cmd
        $cmd 2> /dev/null || true
    fi
}


_remove_all_buildnumber_tags() {
    tmpfile=$(mktemp /tmp/build_shXXXX.tmp)
    $sudo docker image ls --filter reference=$IMAGENAME --format "{{.Tag}} {{.Repository}}" |\
        perl -ne 'if (/^(B\d+\.\d+)\s+(.+)$/) {print "\$sudo docker rmi $2:$1\n"}' > $tmpfile
    [[ "$verbose" ]] && cat $tmpfile
    bash $tmpfile
    rm $tmpfile
}


_exec_command() {
    cmd="${sudo} docker-compose ${dc_opt_prefixed} $@"
    [[ "$verbose" ]] && echo $cmd
    $cmd
    rc=$?
}


_exec_build_command() {
    _exec_command build
    if (( $rc == 0 )); then
        echo "image: ${image_name_tagged} built."
    else
        echo -e '\E[33;31m'"\033[1mError\033[0m Docker build failed"
        exit $rc
    fi
}


_generate_manifest_and_image_build_number() {
    if [[ ! "$MANIFEST_SCOPE" ]]; then
        echo "MANIFEST_SCOPE not set - no build number generated."
        return
    fi
    get_container_status
    is_running=$?
    if (( $is_running == 0 )); then
        echo "Container already running. Cannot generate manifest, image not tagged"
        exit 2
    elif [[ ! -e "$DCSHELL_HOME/manifest.sh"  ]]; then
        echo "cannot run $DCSHELL_HOME/manifest.sh; image not tagged"
        exit 3
    fi
    mkdir -p $DC_PROJHOME/manifest
    manifest_temp="$DC_PROJHOME/manifest/manifest.tmp"
    $DCSHELL_HOME/manifest.sh $dc_opt_prefixed > $manifest_temp
    _exec_command run --rm ${DC_SERVICE} /opt/bin/manifest2.sh | sed -e 's/\r$//' >> $manifest_temp
    build_number_file=$(mktemp)
    python3 $DCSHELL_HOME/buildnbr.py generate $manifest_temp $MANIFEST_SCOPE $build_number_file
    build_number=$(cat $build_number_file)
    rm $build_number_file
}


_tag_with_build_number() {
    newname="${IMAGENAME}:B${build_number}"
    _tag_image
}


_tag_image() {
    cmd="${sudo} docker tag ${IMAGENAME} ${newname}"
    [[ "$verbose" ]] && echo $cmd
    $cmd
    if (( $? == 0 )); then
        echo "Successfully tagged ${IMAGENAME}:B${build_number}"
    else
        echo "Failed to create tag ${IMAGENAME}:B${build_number}"
        exit 4
    fi
}


_untag_image() {
    cmd="${sudo} docker rmi ${newname}"
    [[ "$verbose" ]] && echo $cmd
    $cmd
    (( $? > 0 )) && echo 'untag failed' && exit 5
}


_push_image() {
    # push image if $push is set, with following tagging rules:
    #   push with tag $image_tag or without tag (i.e. :latest) if $push_latest or $image_tag are set
    #   push with build_number if $manifest is set
    # Problem with sudo docker push (https://stackoverflow.com/questions/41984399/denied-requested-access-to-the-resource-is-denied-docker/52036051#52036051(
    if [[ "$push" ]]; then
        if [[ "$image_tag" || "$push_latest" ]]; then
            newname="${DOCKER_REGISTRY_PREFIX}${image_name_tagged}"
            _tag_image
            cmd="docker push ${newname}"
            [[ "$verbose" ]] && echo $cmd
            $cmd
            (( $? > 0 )) && echo 'push failed' && exit 6
            _untag_image
        else
            echo "skipping docker push of :latest"
        fi
        if [[ "$manifest" ]]; then
            newname="${DOCKER_REGISTRY_PREFIX}${IMAGENAME}:B${build_number}"
            _tag_image
            cmd="docker push ${newname}"
            [[ "$verbose" ]] && echo $cmd
            $cmd
            (( $? > 0 )) && echo 'push failed' && exit 6
            _untag_image
        fi
    fi
}


main $@
